---
title: "ARC151_E_solution.md"
tags: []
author: ""
created: ""
---

首先证明：如果 $X$ 和 $Y$ 最长公共子串不为空，最优方案一定是先把 $X$ 删到只剩那个最长公共子串，再补齐到 $Y$。

由于两者最长公共子串不为空，贪心地，我们一定先删到某个较短的串，再补齐。

设 $S$ 为较短串，那么，代价为 $|X|+|Y|-2|S|$。

不会经过别的数，因为代价会凭空增加 $2$。

所以最长公共子串就是最优。

而最长公共子串是 SAM/SA 能轻松解决的问题。

如果最长公共子串为空。

贪心考虑，一个串一定越短越容易被匹配。

所以我们的操作一定是：先删到只剩一个数，加入一个数，删除一个数，$\dots$，直到出现一个数在 $Y$ 中出现，然后补成 $Y$。

由于操作过程中要满足时刻是 $A$ 的子串，而长度最大是 $2$。可以考虑建图， $A_i$ 向 $A_{i+1}$ 连边，表示可以通过一次加入，一次删除，从 $A_i$ 变成 $A_{i+1}$ 或从 $A_{i+1}$ 变成 $A_i$。

由于通过一个点的过渡，必须先加入这个点，再删去这个点，所以这样一定是最优的。

所以就可以让 $X$ 中所有数为起点， $Y$ 中所有数为终点，跑 bfs，操作代价就是 $|X|+|Y|+2 (dis-1)$（删去 $X$，加入 $Y$，和中途转移）。


[代码](https://atcoder.jp/contests/arc151/submissions/35737695)

(-- by cjn)

